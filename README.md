# GAMES102-Assignment04
实现曲线编辑器，包括绘制三次样条、绘制Bezier曲线，编辑曲线

## Assignment 04

Assignment 4 required completing a curve editor. This includes drawing cubic splines and Bezier curves, and editing curves by moving points around the curves.  When editing a cubic spline curve, needs to keep the curve C1 continuous. Bezier curves can be edited to be C0, G1, or C1 continuous. 

### Draw Cubic Spline

A cubic spline is expressed by a cubic polynomial between two adjacent points. 


The cubic spline satisfies C1 continuous. So its first derivative and the second derivative are continuous. By introducing the intermediate variable bending moment, the expression of the polynomial between two points is obtained.


It is solved by matrix operation.


Complete the code according to the formula:

```CPP
std::vector<Ubpa::pointf2> Draw_Spline(Eigen::VectorXf t, std::vector<Ubpa::pointf2> points, float sampling_period) {
	//对于 n + 1 个数据点，相邻两点之间用三次多项式表达，则有 n 段三次多项式
	//用待定系数的方式设第i段向量型多项式函数P(t) = a + bt + ct^2 + dt^3
	std::vector<pointf2> draw_points;
	Eigen::VectorXf M_x = Eigen::VectorXf::Zero(points.size());//对X的M矩阵
	Eigen::VectorXf M_y = Eigen::VectorXf::Zero(points.size());//对Y的M矩阵
	Eigen::VectorXf h(points.size() - 1), b_x(points.size() - 1), b_y(points.size() - 1);//参数向量b
	Eigen::VectorXf u(points.size() - 2), v_x(points.size() - 2), v_y(points.size() - 2), M_mid_x(points.size() - 2), M_mid_y(points.size() - 2);

	//计算相邻两点的矩阵/向量参数
	for (int i = 0; i < points.size() - 1; i++) {
		h(i) = t[i + 1] - t[i];
		b_x(i) = 6.0f * (points[i + 1][0] - points[i][0]) / h(i);
		b_y(i) = 6.0f * (points[i + 1][1] - points[i][1]) / h(i);

		if (i > 0) {
			u(i - 1) = 2.0f * (h(i) + h(i - 1));
			v_x(i - 1) = b_x(i) - b_x(i - 1);
			v_y(i - 1) = b_y(i) - b_y(i - 1);
		}
	}
	//计算Mx=b，中的M矩阵
	if (points.size() == 3) {
		M_mid_x(0) = v_x(0) / u(0);
		M_mid_y(0) = v_y(0) / u(0);
	}
	else if (points.size() == 4) {
		Eigen::Matrix2f A;
		A(0, 0) = u(0);
		A(0, 1) = h(1);
		A(1, 0) = h(1);
		A(1, 1) = u(1);
		M_mid_x = A.colPivHouseholderQr().solve(v_x);//Av_x = M_mid
		M_mid_y = A.colPivHouseholderQr().solve(v_y);//Av_x = M_mid
	}
	else {
		Eigen::SparseMatrix<float> A(points.size() - 2, points.size() - 2);
		A.reserve(Eigen::VectorXi::Constant(points.size() - 2, 3));
		//AM = v_x, AM = v_y, A由u,h组成的对角矩阵，三弯矩
		for (int i = 0; i < points.size() - 2; i++) {
			A.insert(i, i) = u(i);
			if (i > 0)
				A.insert(i, i - 1) = h(i);
			if (i < points.size() - 3)
				A.insert(i, i + 1) = h(i + 1);
		}
		A.makeCompressed();

		//solve the three-moment equations "AM_x=v_x", "AM_y=v_y"
		Eigen::SparseLU<Eigen::SparseMatrix<float>> solver;
		solver.compute(A);
		M_mid_x = solver.solve(v_x);
		M_mid_y = solver.solve(v_y);
	}
	for (int i = 0; i < M_mid_x.size(); i++) {
		M_x(i + 1) = M_mid_x(i);
		M_y(i + 1) = M_mid_y(i);
	}
	for (int i = 0; i < points.size() - 1; i++) {
		for (float t1 = t[i]; t1 <= t[i + 1]; t1 += sampling_period) {
			float x = M_x(i) / (6.0f * h(i)) * pow(t[i + 1] - t1, 3) + M_x(i + 1) / (6.0f * h(i)) * pow(t1 - t[i], 3) + (points[i + 1][0] / h(i) - M_x(i + 1) * h(i) / 6.0f) * (t1 - t[i]) + (points[i][0] / h(i) - M_x(i) * h(i) / 6.0f) * (t[i + 1] - t1);
			float y = M_y(i) / (6.0f * h(i)) * pow(t[i + 1] - t1, 3) + M_y(i + 1) / (6.0f * h(i)) * pow(t1 - t[i], 3) + (points[i + 1][1] / h(i) - M_y(i + 1) * h(i) / 6.0f) * (t1 - t[i]) + (points[i][1] / h(i) - M_y(i) * h(i) / 6.0f) * (t[i + 1] - t1);
			
			const pointf2 pos(x, y);
			draw_points.push_back(pos);
		}
	}
	return draw_points;
}
```



I continued with the four different parameterization methods from Assignment 3. 

- **Equidistant/Uniform parameterization**


- **Chordal parameterization**:

- **Centripetal parameterization**:

- **Foley parameterization**:

- **ALL:**


It can be seen that the cubic spline curves generated by different parameterization methods have obvious differences. 



### Edit the cubic spline

Since the cubic spline satisfies C1 continuity, we just need to move the points to change the curve.


### Draw Bezier Curve

I need to draw segmented Bezier curves with C1 continuity at the endpoints. This is very easy to do with the properties of Bezier curves. Each Bezier curve is plotted by four points, with two control points in the middle generated by two endpoints.


```CPP
//计算三次Bezier曲线
std::vector<Ubpa::pointf2> Draw_Bezier(std::vector<Ubpa::pointf2> control_points, float sampling_period) {
	int n = control_points.size();
	std::vector<Ubpa::pointf2> draw_points;
	for (int i = 0; i < n-3; i+=3) {
		//每四个控制点进行一次三次插值,得到一条Bezier曲线
		for (float t = 0.0f; t < 1.0f; t += sampling_period) {
			float t_x = std::pow(1 - t, 3) * control_points[i][0] + 3 * t * std::pow(1 - t, 2) * control_points[i + 1][0] + 3 * std::pow(t, 2) * (1 - t) * control_points[i + 2][0] + std::pow(t, 3) * control_points[i + 3][0];
			float t_y = std::pow(1 - t, 3) * control_points[i][1] + 3 * t * std::pow(1 - t, 2) * control_points[i + 1][1] + 3 * std::pow(t, 2) * (1 - t) * control_points[i + 2][1] + std::pow(t, 3) * control_points[i + 3][1];
			Ubpa::pointf2 p(t_x, t_y);
			draw_points.push_back(p);
		}
	}
	return draw_points;
}
```

### Edit the Bezier Curve

Change the shape of Bezier curves by changing the control points.  According to the restriction conditions of control points, the curve is determined to be continuous at C0, G1, or C1. 

- **C0 continuous** 


  C0 continuous only needs to be connected to the endpoints, so the position and distance of the control points can be changed at will.



- **G1 continuous**


  G1 continuously needs to keep the endpoints collinear with the control points on both sides, but the distance does not need to be the same, so the distance of a certain end control point can be changed at will under the condition of collinearity. 



- **C1 continuous**

  C1 continuity requires the endpoints to be collinear with the two control points while maintaining equal distances.


code: [Max-shy/GAMES102-Assignment04](
